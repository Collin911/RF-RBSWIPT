%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 函数：射频功率放大器（RF-PA）的二项式拟合输出特性
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%简单的二项式分布计算的输出与输入的关系
%function Pout = RF_PA(Pin)
%    a1 = 10;
%    a2 = -5;
%    Pout = a1.*Pin + a2.*Pin.*Pin;
%end

% 输入和输出都是单位W
% function Pout = RF_PA(Pin)
%     P_size = size(Pin, 2);
%     Pout = zeros(1, P_size);
%     for i = 1:P_size
%         if Pin(1,i) <= 0.1
%             Pout(1,i) = Pin(1,i) * 5;
%         elseif Pin(1,i) < 1
%             Pout(1,i) = Pin(1,i)^0.3+(0.5-0.1^0.3);
%         else
%             Pout(1,i) = 1;
%         end
%     end
% 
% end


% 多项式拟合，这个不行
% 拟合方程式：Y = a + b・X + c・X2 + d・X3 + e・X4 + f・X5 + g・X6 + h・X7 + i・X8 + j・X9 + k・X10
% 参数：
% a = 24.3104769728109
% b = 1.06664496095325
% c = 0.00531795401771232
% d = -0.00481120374867899
% e = -0.000890116275233811
% f = 1.89164285369159E-05
% g = 1.04011823517612E-05
% h = 4.76444163746768E-08
% i = -5.50147634288027E-08
% j = -4.0441142198272E-10
% k = 1.14448153292734E-10
% 相关系数 R2：0.999985032472936
% function Pout = RF_PA(Pin)
%     a = 24.3104769728109;
%     b = 1.06664496095325;
%     c = 0.00531795401771232;
%     d = -0.00481120374867899;
%     e = -0.000890116275233811;
%     f = 1.89164285369159e-05;
%     g = 1.04011823517612e-05;
%     h = 4.76444163746768e-08;
%     ii = -5.50147634288027e-08;
%     j = -4.0441142198272e-10;
%     k = 1.14448153292734e-10;
% %     Y = a + b.*X + c.*X.^2 + d.*X.^3 + e.*X.^4 + f.*X.^5 + g.*X.^6 + h.*X.^7 + i.*X.^8 + j.*X.^9 + k.*X.^10;
%     % 将W修改为dbm
%     %Pin = 10 .* log10(Pin .* 1000);
%     Pin = db(Pin .* 1000)./2;
% %     disp(Pin);
%     
%     % 使用d多项式拟合
%     P_size = size(Pin, 2);
%     Pout = zeros(1, P_size);
%     for i = 1:P_size
%         X = Pin(1,i);
%         if X == -Inf
%             Pout(1,i) = 0;
%         elseif Pin(1,i) <= -12
%             Pout(1,i) = (24.2857) + (1.0303) * Pin(1,i) + (0.002834) * Pin(1,i)*Pin(1,i);
%             Pout(1,i) = 10 .^ (Pout(1,i) ./ 10) ./ 1000;
%         elseif X<=12
%             Pout(1,i) = a + b.*X + c.*X.^2 + d.*X.^3 + e.*X.^4 + f.*X.^5 + g.*X.^6 + h.*X.^7 + ii.*X.^8 + j.*X.^9 + k.*X.^10;
%         else
%             Pout(1,i) = 29.9211;
%         end
%     end
%     % 将输出转换为W
%     Pout = 10 .^ (Pout ./ 10) ./ 1000;
%     for i = 1:P_size
%         if Pout(1,i) < 0
%             Pout(1,i) = 0;
%         end
%     end
% end


% 以该芯片进行计算：https://www.analog.com/media/en/technical-documentation/data-sheets/HMC1132PM5E.pdf
% 输入：2dbm对应93像素点，从-10到14. [-10,-8,-6,-4,-2,0,2,4,6,8,10,12,14]
% 输出：10dbm对应252个像素
% 输出的像素为：[361 411 462 511 562 613 667 713 738 748 752 754 754]，但需要减去2
% 转换为dbm为：[14.2460,   16.2302,   18.2540,   20.1984,   22.2222,   24.2460,
% 26.3889,   28.2143,   29.2063,   29.6032,   29.7619,   29.8413,   29.8413]
% 定义功率放大函数，输入输出均为数组，单位为W
function Pout = RF_PA(Pin)
    % 将W修改为dbm
    Pin = pow2db(Pin) + 30;
    
    
    % 使用三段函数进行拟合
    P_size = size(Pin, 2);
    Pout = zeros(1, P_size);
    for i = 1:P_size
        if Pin(1,i) == -Inf
            Pout(1,i) = 0;
        % 当输入小于2dbm，使用公式Y = a + b・X + c・X2
        elseif Pin(1,i) <= 2.68
            Pout(1,i) = (24.2857) + (1.0303) * Pin(1,i) + (0.002834) * Pin(1,i)*Pin(1,i);
            % Pout(1,i) = 10 .^ (Pout(1,i) ./ 10) ./ 1000;
        % 当输入小于12dbm时，使用公式Y = a + b・X + c・X2 + d・X3 + e・X4
        elseif Pin(1,i) <= 11
             Pout(1,i) = (24.234319)+(1.168514)*Pin(1,i)+(-0.0159875)*(Pin(1,i)^2)+(-0.00995625)*(Pin(1,i)^3)+(0.0005354)*(Pin(1,i)^4);
             % Pout(1,i) = 10 .^ (Pout(1,i) ./ 10) ./ 1000;
        % 当输入大于12dbm时，保持稳定，为29.8413
        else
            Pout(1,i) = 29.74;
            % Pout(1,i) = 10 .^ (Pout(1,i) ./ 10) ./ 1000;
        end
    end

    % 将输出转换为W
    Pout = db2pow(Pout - 30);

end

%使用指数函数，可以指定最高功率。这里使用数学常数作为底
% function Pout = RF_PA(Pin)
%     Pmax = 1;                   %最大功率为1w
%     pmax = log(Pmax);            %计算出对应的指数
%     
%     %p_a = 1;                        %瞬时增益为1时的位置
%     %syms a;
%     %m = solve(1/a * log(1/a) == p_a, a);
%     m = 50;
%     Pout = -exp(-m .* Pin + pmax) + exp(pmax);
% 
% end


% adi芯片拟合
% P_in_dbm = [-15, -13, -11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11];
% P_out_dbm =[7.3, 9.2, 11.5, 13.7, 15.8, 18, 19.8, 21.8, 23.2, 24.5, 25.2, 25.6, 25.7, 25.7]
% 拟合曲线 Y=a +bx + cx^2 + dx^3，不能超过25.7的输入，不然不准确
% a = 22.4135645604395, b = 0.756714180427416, c = -0.0322840762178996, d = -0.00100224530371589


% P_in_mw = [0.0316, 0.0501, 0.0794, 0.1259, 0.1995, 0.3162, 0.5012,
% 0.7943, 1.2589, 1.9953, 3.1623, 5.0119, 7.9433, 12.5893];[19.9526,31.6228,50.1187,79.4328,125.8925]
% P_out_mw =[5.3703, 8.3176, 14.1254, 23.4423, 38.0189, 63.0957, 95.4993,
% 151.3561, 208.9296, 281.8383, 331.1311, 363.0781, 371.5352, 371.5352] [371.5352, 371.5352, 371.5352, 371.5352, 371.5352]
% 拟合曲线，当功率小于3mW时，拟合曲线为：Y = a + b・X + c・X2 + d・X3 + e・X4
% a = -2.989，  b= 220.8015, c = -39.8665, d = -1.0370, e = 0.67382
% 当功率大于3mw时，S型曲线，拟合曲线：y=1/(a+be-x)
% a = 0.002698， b = 0.006375
% function Pout = RF_PA(Pin)
%     Pin = Pin  .* 1000;
%     a1 = -2.989; b1= 220.8015;c1 = -39.8665; d1 = -1.0370; e1 = 0.67382;
%     a2 = 0.002698; b2 = 0.006375;
%     if Pin < 3
%         Pout = a1 + b1.*Pin + c1.*Pin.^2 + d1.*Pin.^3 + e1.*Pin.^4;
%     else
%         Pout = 1/(a2 + b .* e^(-x));
%     end
%     
%     Pout  = Pout ./ 1000;
%         
% end







% 符合实际与期望的功率放大器
% 分三个阶段：低于Pin_min的功率将自动消除；
% 低于Pin_max的功率将线性增益
% 更大的功率将在线性增益基础上加上输入功率，原理是功率分离器
% 单位W
% function Pout = RF_PA(Pin)
%     % 阶段1
%     P_size = size(Pin, 2);
%     Pin_min = 0.01;
%     Pin_max = 0.11;
%     Pout = zeros(1, P_size);
%     
%     if Pin < Pin_min
%         Pout = zeros(1, P_size)
%     elseif Pin < Pin_max
%         Pout = (Pin-Pin_min)*10
%     else
%         Pout = (Pin-Pin_max+Pin_min)+1
%     end
%          
% 
% end








